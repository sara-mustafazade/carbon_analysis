---
title: "carbon_RQ"
output: html_notebook
---

# Analysis per Research Question

## RQ1

```{r}


analysis_sample <- analysis_sample %>%
  mutate(
    cpi10   = carbon_pricing_index/10,             # per +10 CPI pts
    t       = year,                                 # trend index if needed
    lgdppc_c= scale(log_gdp_pc, scale = FALSE),
    ind_c   = scale(industry_share, scale = FALSE),
    ren_c   = scale(renewable_share, scale = FALSE)
  )

# Baseline TWFE (2-way clustered)
m1 <- feols(log_co2 ~ cpi10 + lgdppc_c + ind_c + ren_c | country + year,
            cluster = ~ country + year, data = analysis_sample)

# Driscoll–Kraay SEs
m2 <- feols(log_co2 ~ cpi10 + lgdppc_c + ind_c + ren_c | country + year,
            data = analysis_sample, panel.id = ~ country + year,
            vcov = vcov_DK(~ year, lag = 3))

etable(m1, m2, se.below = TRUE, headers = c("TWFE 2w-cluster","TWFE DK"))

```
```{r}
sun_df <- analysis_sample %>%
  group_by(country) %>%
  mutate(adopt_year = ifelse(any(carbon_pricing_index>0, na.rm=TRUE),
                             min(year[carbon_pricing_index>0], na.rm=TRUE), 0L)) %>%
  ungroup()

m_sun <- feols(log_co2 ~ log_gdp_pc + industry_share + renewable_share +
                 sunab(adopt_year, year) | country + year,
               data = sun_df, cluster = ~ country + year)

iplot(m_sun, ref.line = 0, main = "Event Study: First CPI>0")

```

## RQ2 (Heterogeneity by carbon intensity / renewables)

```{r}
library(dplyr)
library(fixest)

# --- 0) Ensure panel keys exist and are unique --------------------------------
if (!"country" %in% names(merged_final) && "iso3" %in% names(merged_final)) {
  merged_final <- dplyr::rename(merged_final, country = iso3)
}
stopifnot(!anyDuplicated(merged_final[c("country","year")]))

# --- 1) Renewables: normalize column, add lag (we will use the lag in regressions)
# If you have renewable_share_pc (0-100), convert to fraction; otherwise keep renewable_share as-is
merged_final <- merged_final %>%
  mutate(
    renewable_share = dplyr::case_when(
      !is.na(renewable_share) ~ renewable_share,
      !is.na(renewable_share_pc) ~ renewable_share_pc / 100,
      TRUE ~ NA_real_
    )
  ) %>%
  group_by(country) %>%
  arrange(year, .by_group = TRUE) %>%
  mutate(renewable_share_l1 = lag(renewable_share, 1)) %>%
  ungroup()

# --- 2) Build analysis sample (renewables start ~2004; CO2 available to 2023) ---
analysis_sample <- merged_final %>%
  filter(year >= 2004, year <= 2023) %>%
  mutate(
    cpi10    = carbon_pricing_index / 10,         # effect per +10 CPI points
    lgdppc_c = scale(log_gdp_pc, scale = FALSE),  # mean-centered controls
    ind_c    = scale(industry_share, scale = FALSE),
    ren_c    = scale(renewable_share, scale = FALSE),
    ren_c_l1 = scale(renewable_share_l1, scale = FALSE),
    t        = year
  ) %>%
  tidyr::drop_na(log_co2, cpi10, lgdppc_c, ind_c, ren_c_l1)  # use lagged renewables to reduce endog.

stopifnot(!anyDuplicated(analysis_sample[c("country","year")]))

# --- 3) TWFE models ------------------------------------------------------------
# 3a) Baseline (two-way clustered)
m1 <- feols(
  log_co2 ~ cpi10 + lgdppc_c + ind_c + ren_c_l1 | country + year,
  cluster = ~ country + year,
  data = analysis_sample
)

# 3b) Driscoll–Kraay (needs panel.id + DK time index)
m2 <- feols(
  log_co2 ~ cpi10 + lgdppc_c + ind_c + ren_c_l1 | country + year,
  data     = analysis_sample,
  panel.id = ~ country + year,
  vcov     = vcov_DK(~ year, lag = 3)
)

# 3c) Country-specific linear trends (robustness)
m3 <- feols(
  log_co2 ~ cpi10 + lgdppc_c + ind_c + ren_c_l1 | country[t] + year,
  cluster  = ~ country + year,
  data     = analysis_sample
)

# 3d) Dynamics: CPI lags 0–2 with DK SEs
m4 <- feols(
  log_co2 ~ l(cpi10, 0:2) + lgdppc_c + ind_c + ren_c_l1 | country + year,
  data     = analysis_sample,
  panel.id = ~ country + year,
  vcov     = vcov_DK(~ year, lag = 3)
)

etable(m1, m2, m3, m4, se.below = TRUE,
       headers = c("TWFE 2w-cluster","TWFE DK","TWFE+trends","TWFE+lags"))

# Cumulative CPI effect over 0–2 years (robust to naming quirks)
lag_names <- grep("^l\\(cpi10,\\d\\)$", names(coef(m4)), value = TRUE)
b <- coef(m4)[lag_names]; V <- vcov(m4)[lag_names, lag_names, drop = FALSE]
cum_est <- sum(b); cum_se <- sqrt(t(rep(1, length(b))) %*% V %*% rep(1, length(b)))
cum_z <- as.numeric(cum_est / cum_se); cum_p <- 2 * pnorm(-abs(cum_z))
c(cum_est = cum_est, se = cum_se, z = cum_z, p = cum_p)

```

## RQ3 Dynamics Lags

```{r}
m_dyn <- feols(log_co2 ~ l(cpi10,0:2) + lgdppc_c + ind_c + ren_c | country + year,
               data = analysis_sample, panel.id = ~ country + year,
               vcov = vcov_DK(~ year, lag = 3))

# Cumulative CPI effect over 0–2 years (robust to naming issues)
lag_names <- grep("^l\\(cpi10,\\d\\)$", names(coef(m_dyn)), value = TRUE)
b <- coef(m_dyn)[lag_names]; V <- vcov(m_dyn)[lag_names, lag_names]
est <- sum(b); se <- sqrt(matrix(1,1,3) %*% V %*% matrix(1,3,1)); z <- est/se; p <- 2*pnorm(-abs(z))
c(cum_est = est, se = se, z = z, p = p)

```

```{r}
# Baseline intensity pre-2004
base_int <- merged_final %>%
  filter(year >= 2000, year <= 2003) %>%
  mutate(intensity = co2 / gdp) %>%
  group_by(country) %>%
  summarise(base_int = median(intensity, na.rm = TRUE), .groups = "drop")

analysis_sample <- analysis_sample %>%
  left_join(base_int, by = "country") %>%
  mutate(base_int_c = scale(base_int, scale = FALSE))

m_het_intensity <- feols(
  log_co2 ~ cpi10*base_int_c + lgdppc_c + ind_c + ren_c_l1 | country + year,
  cluster = ~ country + year, data = analysis_sample
)
etable(m_het_intensity, se.below = TRUE)

```

## RQ 4 5

```{r}
# Lag EPS to reduce simultaneity
analysis_sample <- analysis_sample %>%
  group_by(country) %>% arrange(year, .by_group = TRUE) %>%
  mutate(eps_l1 = lag(oecd_value, 1)) %>%
  ungroup() %>%
  mutate(eps_c = scale(eps_l1, scale = FALSE))

m_eps <- feols(
  log_co2 ~ cpi10*eps_c + lgdppc_c + ind_c + ren_c_l1 | country + year,
  cluster = ~ country + year, data = analysis_sample
)

# ETS phases (interactions only; main effects collinear with year FE)
analysis_sample <- analysis_sample %>%
  mutate(phaseII  = (year>=2008 & year<=2012),
         phaseIII = (year>=2013 & year<=2020),
         phaseIV  = (year>=2021 & year<=2023))

m_phase <- feols(
  log_co2 ~ cpi10:phaseII + cpi10:phaseIII + cpi10:phaseIV +
            lgdppc_c + ind_c + ren_c_l1 | country + year,
  cluster = ~ country + year, data = analysis_sample
)
# Is Phase IV stronger than earlier phases?
wald(m_phase, "cpi10:phaseIV = cpi10:phaseIII")
wald(m_phase, "cpi10:phaseIV = cpi10:phaseII")

```

# Analysis per Research Question

## RQ1 / H1 Average causal impact

```{r}

# Main (per-capita outcome)
m1 <- feols(log_co2_pc ~ lcpi + ren_c + lgdppc_c + ind_c | iso3 + year,
            cluster=~iso3, data=analysis_sample)

# With country-specific linear trends (absorbs slow paths)
m1_tr_i <- feols(log_co2_pc ~ lcpi + ren_c + lgdppc_c + ind_c + i(iso3, t) | iso3 + year,
  cluster = ~ iso3, data = analysis_sample
)

# Totals as robustness, controlling for size (STIRPAT-style)
m1_tot <- feols(log_co2 ~ lcpi + log_pop + log_gdp_pc + ren_c + ind_c | iso3 + year,
                cluster=~iso3, data=analysis_sample)
etable(m1, m1_tr_i, m1_tot, se.below=TRUE,
       headers=c("Per-capita","Per-capita+trends","Totals"))

```
## RQ 3 / H3 Dynamics
```{r}
# Main Specification: Per-capita emissions with lags
m_main <- feols(
  log_co2_pc ~ l(cpi10, 0:2) + lgdppc_c + ind_c + ren_c | country + year,
  data     = analysis_sample,
  panel.id = ~ country + year,
  vcov     = vcov_DK(~ year, lag = 3)
)

# Robustness Check: Total emissions with size controls and lags
m_robust <- feols(
  log_co2 ~ l(cpi10, 0:2) + log_pop + log_gdp_pc + ind_c + ren_c | country + year,
  data    = analysis_sample,
  panel.id = ~ country + year,
  vcov     = vcov_DK(~ year, lag = 3)
)

etable(m_main, m_robust, se.below = TRUE,
       headers = c("Per-capita (main)","Totals (robustness)"))
```

Two-way FE with Driscoll–Kraay SEs shows no contemporaneous CPI effect, but a one-year-lagged reduction of ~1.5% (per-capita) and ~2.1% (totals) per +10 €/t increase in the carbon price. The 2-year lag is small and insignificant, consistent with adjustment occurring within roughly a year. We’re stacking level lags of a highly persistent policy (CPI), so the t+1 effect shows the first round of adjustment, while t+2 gets diluted by (i) multicollinearity with newer CPI levels, (ii) front-loaded abatement, and (iii) annual measurement/budget cycles.

```{r}
# Formally testing cumulative effect over 0-2 years
# Wald test for m_main, m_robust

cum_wald <- function(mod, coefs = c("cpi10","l(cpi10, 1)","l(cpi10, 2)")) {
  nm  <- names(coef(mod))
  idx <- match(coefs, nm)
  if (any(is.na(idx))) stop("Missing coefs: ", paste(coefs[is.na(idx)], collapse=", "))

  b <- coef(mod)[idx]
  V <- vcov(mod)[idx, idx, drop = FALSE]  # uses the model's DK vcov
  L <- matrix(1, nrow = 1, ncol = length(idx))

  est <- as.numeric(L %*% b)
  se  <- sqrt(as.numeric(L %*% V %*% t(L)))
  z   <- est / se
  p   <- 2 * pnorm(abs(z), lower.tail = FALSE)
  ci  <- est + c(-1, 1) * 1.96 * se
  list(est = est, se = se, z = z, p = p, ci = ci)
}

res_main   <- cum_wald(m_main)
res_robust <- cum_wald(m_robust)
res_main
res_robust

```
Two-way FE with Driscoll–Kraay SEs shows no contemporaneous CPI effect, but a cumulative two-year reduction of ≈1.0% (per-capita) and ≈1.9% (totals) for a one-time +10 €/t increase in carbon price (95% CIs [−1.90, −0.17] and [−2.82, −0.96]). The decline is concentrated at t+1.


Checking lag collinearity:
```{r}

tmp <- analysis_sample %>%
  arrange(country, year) %>%
  group_by(country) %>%
  mutate(cpi_l1 = lag(cpi10), cpi_l2 = lag(cpi10, 2)) %>%
  ungroup()

with(tmp, c(
  cor01 = cor(cpi10, cpi_l1, use="pair"),
  cor02 = cor(cpi10, cpi_l2, use="pair"),
  cor12 = cor(cpi_l1, cpi_l2, use="pair")
))

```
Problem: Multicollinearity of Lags
The lagged values of CPI are highly correlated with each other (e.g., cor(cpi10, lag(cpi10)) ≈ 0.92).

The Solution: Almon Polynomial Distributed Lags (PDL)
The Almon lag (or PDL) model is designed specifically to solve this problem. Instead of estimating a separate coefficient for each lag, it imposes a structure, assuming the coefficients of the lags lie along a smooth polynomial curve (in your case, a 2nd-degree polynomial, which is a parabola).

This approach overcomes multicollinearity by estimating the shape of the lag effect rather than each individual point, resulting in more stable and efficient estimates.
```{r}

analysis_sample$year <- as.integer(analysis_sample$year)

# sanity: no duplicate country-year rows?
any(duplicated(analysis_sample[c("country","year")]))

m_l3 <- feols(
  log_co2_pc ~ l(cpi10, 0:3) + lgdppc_c + ind_c + ren_c | country + year,
  data      = analysis_sample,
  panel.id  = ~ country + year,               # <-- add this
  vcov      = vcov_DK(~ year, lag = 3)
)
etable(m_l3, se.below = TRUE)

cum_wald(m_l3, coefs = c("cpi10","l(cpi10, 1)","l(cpi10, 2)","l(cpi10, 3)"))

```


```{r}
#Smoothed distributed lag (Almon PDL): 
feols(log_co2_pc ~ almon(cpi10, 0:3, 2) + lgdppc_c + ind_c + ren_c | country + year,
      data = analysis_sample,
      panel.id = ~ country + year, 
      vcov = vcov_DK(~year, lag = 3))

m_almon <- feols(
  log_co2_pc ~ almon(cpi10, 0:3, 2) + lgdppc_c + ind_c + ren_c | country + year,
  data     = analysis_sample,
  panel.id = ~ country + year,
  vcov     = vcov_DK(~ year, lag = 3)
)

as_lp <- analysis_sample |>
  dplyr::arrange(country, year) |>
  dplyr::group_by(country) |>
  dplyr::mutate(dcpi = cpi10 - dplyr::lag(cpi10)) |>
  dplyr::ungroup()

run_lp <- function(h) feols(flead(log_co2_pc, h) ~ dcpi + lgdppc_c + ind_c + ren_c |
                            country + year, data = as_lp, vcov = vcov_DK(~year, lag = 3))
etable(lapply(0:3, run_lp), headers = paste0("h=",0:3), se.below=TRUE)


```
```{r}
pkgbuild::has_build_tools(debug = TRUE)

# Change the download method
options(download.file.method = "libcurl")

# Try installing again
remotes::install_github("lrberge/fixest")

install.packages("C:/Users/sara/Downloads/lrberge-fixest-v0.13.2-7-g7e79024.tar.gz", repos = NULL, type = "source")
```
```{r}
# To install from CRAN:
install.packages("fixest")

# To install the latest stable development release:
install.packages("fixest", 
                 repos = c(ropensci = 'https://fastverse.r-universe.dev',
                           CRAN = 'https://cloud.r-project.org'))
```


